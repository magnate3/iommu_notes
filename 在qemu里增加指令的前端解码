-v0.1 2012.12.15 Sherlock init

简介：本文梳理在qemu里增加一个指令的前端解码的基本逻辑，文中会加入一个具体的例子。


qemu基础逻辑
------------

 qemu虚拟机提供两种CPU实现的方式，一种是基于tiny code的实现，一种是基于KVM的实现。

 第一种方式，我们一般叫tcg(tiny code generator)，这种方式的基本思路是用纯软件的
 方式把target CPU的指令先翻译成所谓的tiny code，然后再把tiny code翻译成host CPU
 的指令，我们把target CPU指令翻译成tiny code的过程叫整个过程的前端，tiny code翻译
 成host CPU的过程对应的叫做后端。给qemu增加一个新CPU的模型需要既增加前端也增加后端，
 如果要把整个系统支持起来，还要增加基础设备以及user mode的支持，整个系统的支持的
 逻辑不在本文档里展开，本文只聚焦于前端的相关逻辑。如果目的是在一个成熟的平台上
 验证另一个新的CPU，比如在x86机器上跑riscv的虚拟机，验证riscv的逻辑，只需要加上
 riscv指令到tiny code这个前端支持就好，因为tiny code到x86的后端已经存在；如果目的
 是，比如在一台riscv的机器上模拟x86，就需要加tiny code到riscv的后端支持，我们这里
 以riscv为例子，把它作为一个需要支持的CPU构架。

 一个完整的riscv到tiny code前端支持的例子可以参考：
 https://lore.kernel.org/all/1519344729-73482-1-git-send-email-mjc@sifive.com

 以riscv为例子，体系相关的前端的代码在：target/riscv/*，后端的代码在：tcg/riscv/*，
 基础外设和machine的代码在hw/riscv/*

 基于KVM的方式，直接使用host CPU执行target CPU的指令，性能接近host上的性能，但是
 需要target CPU和host CPU是相同的构架。本文不讨论KVM的逻辑。

qemu tcg前端解码逻辑
--------------------

 把target cpu指令翻译成host cpu指令有两种方式，一种是使用helper函数，一种是使用
 tiny code generator函数的方式。helper函数的方式还没有分析，现在只看tcg的方式。

 我们把逻辑拉高一层看问题，所谓target CPU的运行，实际上是根据target CPU指令流去
 不断的改变target CPU软件描述结构里的数据状态，因为实际的代码要运行到host CPU上，
 所以，target代码要被翻译成host代码，才可以执行，通过执行改变target CPU的数据状态。
 qemu为了解耦把target CPU代码先翻译成tiny code，那么翻译成的tiny code的语义也就是
 改变target CPU数据状态的一组描述语句，所以target CPU状态参数会被当做入参传入tiny
 code描述语句。这组tiny code是改变CPU状态的抽象的描述，有些CPU上的状态不好抽象成
 一般的描述就用helper函数的方式补充，所以helper函数也是改变target CPU状态的描述。

 tcg的方式，我们要使用tcg_gen_xxx的函数组织逻辑描述target CPU指令对target CPU状态
 的改变。一些公共的代码是可以自动生成的，qemu里使用decode tree的方式自动生成这一部
 分代码。

 以riscv的代码来具体说明。qemu定义了一组target CPU指令的描述格式，说明文档在：
 docs/devel/decodetree.rst，riscv的指令描述在target/riscv/insn16.decode、insn32.decode
 里，qemu编译的时候会解析.decode文件，生成对应的定义和函数，生成的文件放在
 qemu/build/libqemu-riscv64-softmmu.fa.p/decode-insn32.c.inc，decode-insn16.c.inc里。
 这些文件生成的trans_xxx函数需要自己实现，riscv的这部分实现是放在了在target/riscv/insn_trans/*里。
 生成的文件里有两个很大的解码函数decode-insn32.c.inc和decode-insn16.c.inc，qemu
 把target CPU指令翻译成tiny code的时候就需要调用上面两个解码函数。

 我们用riscv user mode的代码来看看上层具体调用关系。qemu提供system mode和user mode
 的模拟方式，其中system mode会完整模拟整个系统，一个完成的OS可以运行在这个模拟的
 系统上，user mode只是支持加载一个target CPU构架的用户态程序来跑，对于一般指令
 使用tcg的方式翻译执行，对于用户态程序里的系统调用，user mode代码里模拟实现了系统
 调用的语意。linux user mode的代码在qemu/linux-user/*，具体的调用过程如下：

```
 /* qemu/linux-user/main.c */
 main
   +-> cpu_loop
     +-> cpu_exec
       +-> tb_gen_code
             /* qemu/target/riscv/trannslate.c */
         +-> gen_intermediate_code
	   +-> translator_loop(&riscv_tr_ops, xxx)
	         /* riscv_tr_translate_insn */
	     +-> ops->translator_insn
	       +-> decode_ops
	         +-> decode_insn16
		 +-> decode_insn32
```
 
 基本逻辑就是这样。下面展开其中的各个细节看下，细节上大概有这么几块：

 1. tcg整个翻译流程构架分析
 2. decode tree的语法
 3. tcg trans_xxx函数的语法

tcg翻译流程
-----------

decode tree语法
-----------------

trans_xxx函数语法
-----------------

