uacce fork功能
==============

-v0.1 2021.11.10 Sherlock init
-v0.2 2021.11.11 Sherlock 数据同步分析的有问题，重新推了一下这部分，发现有问题会使内核break。

简介：我们计划在uacce/uadk里加上fork的功能，简单讲就是fork之后子进程无需再次申请
      加速器的资源，父进程中的加速器资源在子进程里fork了一份新的，子进程可以直接
      使用fork出的新资源下发相关的计算任务。本文梳理整个设计的逻辑。

1. 需求
-------

 进程拥有CPU和加速器这两种计算资源，这两种计算资源的使用方式不同。其中的一个不同
 的地方是多个上下文，比如进程，在使用加速器之前必须重新申请加速器资源，具体到uacce
 里，如果在新进程使用加速器，比如重新open加速器设备并且初始化队列相关资源。

 如果，加速器可以作为一个异构的计算单元，以类似CPU的方式访问，那么使用就会方便很多。
 具体到uacce上看，就是申请一次队列资源，mmap了mmio/dus，后面进程再次fork，子进程
 里的mmio/dus接口直接就可以用，直接通过mmio/dus发送计算请求就好，相关计算请求和
 子进程的地址空间绑定。

2. 基本逻辑
-----------

 要做到如上的特性，需要解决三个问题：1. fork队列，需要在内核里给子进程申请新的
 队列，用父进程里的队列是不行的，因为这会出现父子进程同时操作一个队列的情况，队列
 的状态做不到同步; 2. 需要把新队列的控制路径打通，重建mmio/dus的map; 3. 需要叫
 新对队列可以认知子进程的地址空间，做新队列和子进程mm的sva_bind.

 fork队列也就是要fork fd，这个和目前fork对文件的影响的含义是不一样的，当前linux
 内核里，fork的父子进程中相同的fd拥有相同的struct file，也就是说父子进程中fork
 的fd还是一样的文件上下文。我们需要的是，fork后子进程的fd有自己的文件上下文，这样
 才可以挂上新的队列。所以，可有给文件添加一个新的属性，他的语义是在fork进程的时候
 为文件在子进程里创建新的上下文，暂时把这个属性叫做O_FORK。

 具体实现，可以在fork->copy_files里判断一个fd是否有O_FORK，如果有就新创建struct file，
 还需要在file的回调里增加fork的回调，用来支持file私有数据的创建。struct file的指针
 会在其他地方引用，比如在vma里就有vm_file，对于有O_FORK的file，需要在每个具体的地方
 把原来file的指针改成新的指针。

 重建mmio/dus的map要找一个合适的点，可以在vma_open里做，也可以在vma_fault里做。
 vma_open里做比较直白，子进程vma和新队列作为参数重新map即可(注意，如上所说，这里
 需要对O_FORK标记的file做vm_file的更新)。使用vma_fault做需要触发缺页，目前uacce里
 对vma加了两个控制flag：VM_DONTCOPY，VM_WIPEONFORK。VM_DONTCOPY需要去掉，如果保留
 这个flag，子进程里都没有vma，vma fault流程是救不回来的，直接会segment fault，
 VM_WIPEONFORK存在时，fork的时候不会拷贝页表和做写保护，对于父进程，依然可以继续读写，
 对于子进程有vma但是没有页表，访问mmio/dus会走到vma_fault，这条路是通的，VM_WIPEONFORK
 不可以去掉，去掉后fork时会进入copy_page_range，但是内核现在对remap_pfn_range特殊
 处理，认为这段地址不是COW的，这样会导致父子进程的mmio/dus的map都是父进程里原来的map，
 细节上dus的map还有特殊的情况会出现，dus使用dma_mmap_coherent做map，依据内存分配
 的方式，map的方式可以有remap_pfn_range或者vm_map_pages。综合以上，我们可以用vma_open
 做(需要去掉VM_DONTCOPY, VM_WIPEONFORK的有无没有影响，反正随后的vma open里都要重新
 map)，也可以用vma_fault做(需要去掉VM_DONTCOPY，保留VM_WIPEONFORK)

 mmio/dus map需要考虑的数据同步的问题。一般的，我们在dus上准备BD，在mmio上发送
 doorbell，并在dus上接收任务，当然也可以只用mmio完成任务的发送和接收。我们需要考虑
 的情况有: 1. fork出现在dus一个BD填写中间，2. fork出现在mmio一个doorbell的填写中间，
 3. fork出现在任务的发送和接收中间, 4. fork出现在接收任务中间。mmio/dus在子进程里都
 是重新申请的，所以父进程mmio/dus里的内容在子进程里都没有，子进程mmio/dus的状态是
 在用户态维护的，会继承父进程的状态，这么看来，子进程投入运行时会有很多错误发生，
 一个解决的办法是在fork的过程中把父进程的mmio/dus的内容拷贝到子进程的mmio/dus。
 我们来一个一个分析上面的四种情况，首先四种情况中父进程都不会出错，父进程被fork
 打断了，回来继续跑就是，第一种情况中，子进程不会错，因为做了dus的拷贝，第二种情况
 比较特殊，我们假设写mmio不是原子的(比如doorbell)，如果是原子的就没有这种情况了，
 也不会出问题，同样是做了mmio的拷贝，但是父子进程里会有一个相同的任务，第三种情况,
 父进程里的加速器已经跑了起来，在fork的时候做mmio/dus的拷贝会有一个问题，就是这个
 时候子进程里的fd还可能还没有和子进程地址空间绑定，这个时候触发一个加速器的计算任务，
 加速器访问内存的时候会出错！！第四种情况，子进程里根本没有发这个包，子进程会一直
 收不到包。如果我们向用户提出约束，不能在收发包的时候fork，但是，如果用户违反，那么
 上面的第三种情况会直接导致内核出问题，这个是不可以接受的！！第三种情况导致的一个约束
 mmio/dus的拷贝必须在子进程fd和地址空间bind之后，vma_fault里实现可以解决这个问题，
 vma_open里实现，仔细编码(vma_open在fd和地址空间绑定之后)也可以实现。

 新队列做sva_bind和fd fork是两个独立的问题。uacce在open文件时给文件赋予了认知当前
 地址空间的能力，我们要做的是在fork fd的时候，在子进程里为fd保留这个能力。这个问题
 可以从fd和mm的角度分别独立看待。从fd角度看待，是uacce这个特殊的驱动赋予了fd这个
 能力，最直接的方式就是uacce对于新的fd再重新赋予一下，uacce和系统可以接通的地方
 现在看来只有vma_open和vma_fault，但是在这两个函数里做sva_bind一个是语义不符，一个
 是有重复加锁的问题; uacce还可以向用户态报告，然后用户态在调用uacce的接口，比如可以
 新加一个ioctl，重新把子进程地址空间和fd绑定下; 还有一个思路，是把fd感知地址空间
 这个语义向上扩展，也就是继续加fd的flags，并且在fork的时候对有flag标记的文件做新地址
 空间的绑定。从mm这个角度看，mm原来只是cpu看到的地址空间，现在设备也有能力看到，
 在mm复制的时候，是不是也应该保留设备的这种能力？这里有一个问题，现在单从mm这个结构
 里你根本不知道是否还有其他设备也可以看到这个地址空间，道理上讲mmu和iommu看到同样
 的地址空间，两者之间必然有同步的需求，现在这个同步的需求是通过mmu_notifier做的，
 cpu在变动地址空间的时候调用iommu之前注册到mm上的回调函数做同步，所以虽然mm里没有
 显示的维护有可能看到同样地址空间的其他设备，但是实际上是通过mmu_notifier间接联系
 的，那mm的fork也应该通过这个渠道和设备这边建立联系。特别是如果设备都有了fork这个
 能力，没有理由不叫之前认知地址空间的能力也fork。综合以上，我们可以配合用户态做
 新队列的地址空间绑定也可以尝试在内核里搞定，我们可以首先尝试在内核里搞定。
