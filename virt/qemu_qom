qemu code analysis - qom
========================

-v0.1 2021.4.29 Sherlock init

qemu里使用面向对象的模型来模拟相关的元素，可以想象这样的模拟是很合理的，比如，
用device描述一个设备的基类，pci_device可以继承device，然后vfio的pci设备又可以
继承pci_device，同时一个用纯用软件模拟的pci网络设备也可以继承pci_device。

本文描述这个基于面向对象的思路构建起来的qemux模型。分析基于qemu 5.2.92版本。

1. 对象的定义
-------------

 type_init(fn)
       /* 用宏定义了一个动态库的初始化函数, qemu编译出的库有？*/
   +-> module_init
    +-> register_module_init
      +-> e->init = fn

2. 对象的生成
-------------

 /* class的生成：qemu/softmmu/main.c */
 main
   +-> qemu_init
     +-> qemu_init_subsystems
           /* 根据TypeInfo创建class */
       +-> module_call_init(MODULE_INIT_QOM)
             /*
	      * init即为如上的fn, 这里的init只是把TypeInfo向qemu注册，类的
	      * 初始化还在后面
	      */     
         +-> ModuleEntry->init
	   ...?
	       /* 初始化class，哪里会调用？*/
	   +-> type_initialize


 /* 具体device对象的生成？*/

3. 一个例子
-----------
 
 这里写一个dma engine的qemu设备，在写一个与之配套的iommu设备。

 smmuv3的父设备的代码里有：
 smmu_base_realize
   +-> pci_setup_iommu  smmu_find_add_as

 把一个smmu的AS相关的信息告知给pci bus，后续pci device初始化的时候会的到这个信息，
 pci device随后发dma的时候通过这个smmu的as信息得到smmu里的translate函数然后做翻译

 我们可以看一个具体的intel e1000的虚拟网卡：qemu/hw/net/e1000.c
 在这个设备注册的时候会调用：

 /* qemu/hw/pci/pci.c */
 do_pci_register_device
   +->pci_init_bus_master
     +-> AddressSpace *dma_as = pci_device_iommu_address_space
           /* 这个iommu_fn就是上面的smmu_find_add_as */
       +-> iommu_bus->iommu_fn

 设备模拟一个dma读写的实现：
 pci_dma_read/write
   ...
     /* pci_get_address_space_space得到dev->bus_master_as */
     +-> dma_memory_rw(pci_get_address_space(dev), ...)
