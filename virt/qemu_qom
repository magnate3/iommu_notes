qemu code analysis - qom
========================

-v0.1 2021.4.29 Sherlock init
-v0.2 2021.5.03 Sherlock draft finish 2,3

qemu里使用面向对象的模型来模拟相关的元素，可以想象这样的模拟是很合理的，比如，
用device描述一个设备的基类，pci_device可以继承device，然后vfio的pci设备又可以
继承pci_device，同时一个用纯用软件模拟的pci网络设备也可以继承pci_device。

本文描述这个基于面向对象的思路构建起来的qemux模型。分析基于qemu 5.2.92版本。

0. 用c语言实现面向对象的模型
----------------------------

 qemu里用c语言实现了面向对象的模型。我们先梳理用c实现面向对应的基本逻辑。面向对象
 的三个特征是：封装、继承和多态。封装可以用struct实现。继承可以用struct包含的方式
 实现，把父类的struct放到子类struct的最开始的位置，这样子类的指针可以直接强制转换
 成父类的指针，在子类的函数，比如子类的初始化函数里可以直接得到父类的指针，然后调用
 父类的初始化函数。多态可以用函数指针的方式实现。

 qemu里的实现，多了TypeInfo这个概念，它是class的描述。

1. 对象的定义
-------------

 type_init(fn)
       /* 用宏定义了一个动态库的初始化函数, qemu编译出的库有？*/
   +-> module_init
    +-> register_module_init
          /* 如下都用edu设备举例，这里的fn就是pci_edu_register_types */
      +-> e->init = fn
 
 fn这个函数一般是TypeInfo的注册函数, 把TypeInfo挂到系统的链表里。class是随后解析
 Typeinfo的内容动态生成的。

2. 对象的生成
-------------

 /* class的生成：qemu/softmmu/main.c */
 main
   +-> qemu_init
     +-> qemu_init_subsystems
           /* 根据TypeInfo创建class */
       +-> module_call_init(MODULE_INIT_QOM)
             /*
	      * init即为如上的fn, 这里的init只是把TypeInfo向qemu注册，类的
	      * 初始化还在后面
	      */     
         +-> ModuleEntry->init
	   ...?
	       /* 初始化class，哪里会调用？type_initialize是根据注册的Type创建
	        * class的函数。但是，一时找不见哪里调用，但是可以看到，创建class
		* 的具体实例的时候，如果class没有创建，就会创建class，被创建的class
		* 的指针会放到注册Type的class域段。所以下面的type_initialize的调用
		* 关系并不准确。
		*/
	   +-> type_initialize
	       /* e.g. qemu/hw/misc/edu.c会调用到edu_class_init */
	     +-> edu_class_init
	           /* 得到PCIDeviceClass的指针是pci edu这个类的么？*/
	       +-> PCI_DEVICE_CLASS
     ...

     +-> qemu_opts_parse_noisily(qemu_find_opts("device"), ...)
     +-> qmp_x_exit_preconfig
       +-> qemu_create_cli_devices
             /* 遍历初始化之前扫描到的-device里的信息？*/
         +-> device_init_func
	   +-> qdev_device_add
	     +->qdev_new
	       +-> object_new
	       ...

 Type里的realize的函数是怎么调用到的。

3.properties是什么
------------------

 所谓属性，就是在一个对象里定义的一些功能，这些功能有名字，有对应的执行函数，还有
 添加和删除函数。当添加一个属性的时候，就是把这个属性已经对应的执行函数保存到对象
 专门用来存各种属性的一个hash table。当执行属性的操作时，就是执行对应属性附带的
 执行函数。

 我们还是拿edu这个设备为例。edu在实例初始化的时候挂给PCIDeviceClass的realize一个
 回调函数pci_edu_realize，这个函数就是PCI设备里realize属性的执行函数。我们需要明确
 这个realize属性在哪里添加和在哪里调用。

 device class的初始化函数里增加了realized属性：
 /* hw/core/qdev.c */
 device_class_init
      /*
       * 把realized属性加到ObjectClass里。device_set_realized里会调用DeviceClass里的
       * realize回调函数。DeviceClass里的realize回调在pci_device_class_init里挂成
       * pci_qdev_realize。pci_qdev_realize调用PCIDeviceClass里的realize函数，这个
       * 函数又是由具体设备的class init函数添加，比如edu的edu_class_init。
       */
   -> object_class_property_add_bool(ObjectClass, "realized", device_get_realized, device_set_realized)

 在如上的qdev_device_add里，在创建了设备的实例后，后调用qdev_realize把设备realize，
 这个函数会从Device这一层，层层的调用realize函数:
 /* hw/core/qdev.c */
 qdev_realize
   -> object_property_set_bool(OBJECT(dev), "realized", true, errp)
     [...]
     -> object_property_set
          /* 可以看到realized相关的add和find都是发生在Object、ObjectClass这个层次 */
       -> ObjectProperty *prop = object_property_find(obj, name, errp)
            /* 先用obj找到ObjectClass，再在ObjectClass找property */
         -> object_class_property_find(klass, name, NULL)
	    /* 在Object里找property */
         -> g_hash_table_lookup(obj->properties, name)

       -> prop->set(obj, v, name, prop->opaque, &err)

 如上，分析qemu的qom重点关注如下的文件: hw/misc/edu.c, hw/pci/pci.c, hw/core/qdev.c,
 qom/object.c。各个层级的Type定义分别对应的文件里(这里用pci设备为例)

 link属性

 child属性

4.interface
-----------


5. 一个例子
-----------
 
 这里写一个dma engine的qemu设备。
