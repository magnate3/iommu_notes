-v0.1 2021.10.26 Sherlock init

简介：本文是《超标量处理器设计》这本书的读书笔记。总的来看这本书的难度在《计算机组成与设计-硬件软件接口》
      和《计算机体系结构量化研究方法》之间。这本书主要讲的是超标量处理器各个部件
      的设计原理。

概览
----

 为了使处理器里的流水线全速工作，我们要尽量去掉指令和指令之间的依赖。指令之间的
 依赖有WAW，WAR，RAW以及控制依赖，只有RAW和控制依赖是真依赖，其他两种依赖都可以
 靠寄存器重命名来缓解。load/store地址之间也存在着依赖。

 一个周期可以去除多条指令送到流水线里执行，这个处理器就是超标量处理器了。超标量
 处理器又分顺序执行和乱序执行。所谓乱序执行，是指处理器内部执行指令的时候是乱序
 执行的，从程序员的视角看，程序是按顺序执行的，不过，对于不同处理器会有不同程度
 的放松，比如在没有数据依赖的时候，对不同地址的load/store可能是乱序完成的。

 一个周期执行多条指令并不是说一个处理器里有多条一样的流水线，一个处理器里有多个
 不同的执行单元就可以把不同的指令发射到不同的执行单元里执行。

 一般我们可以把执行单元分为：ALU(ADD/LOGIC)，ALU(MUL/DIV), LOAD/STORE, FP/SIMD等。
 一个超标量处理器的大概模型如下：

```
                               +-------+   +----+
                     +-----+-->|issue q|-->| EX |\
                     |issue|   +-------+   +----+ \
                     |logic|                       \                     +---+
   +----+    +----+  |     |   +-------+   +----+   \+-----+    +----+-->|ROB|
   | IF |--->| ID |->|     |-->|issue q|-->| EX |--->| MEM |--->| WB |   +---+
   +----+    +----+  |     |   +-------+   +----+   /+-----+    +----+-->+---+
                     |     |                       /                     |SB |
                     |     |   +-------+   +----+ /                      +---+
                     +-----+-->|issue q|-->| EX |/
                               +-------+   +----+
```
 一般，我们把取指(IF)、译码(ID)看做前端(front-end)，发射(issue)、执行(EX)、内存操作(MEM)
 写会(WB)以及提交叫做后端(back-end)。

cache
-----

 todo

虚拟存储器
----------

 todo

分支预测
--------

 想要充分使用流水线就要预取指令执行，顺序执行的指令直接预取就可以，但是到了分支
 的时候，就要选择一条分支来预取，这时就存在各种分支预测的实现方式。分支预测的各种
 实现可以暂时当做黑盒来对待。预取的指令可以提前在流水线里执行，但是在分支结果出来
 之前不能提交。分支结果出来后，如果预取分支是对的，那么直接提交执行的结果就可以，
 但是，如果分支取错了就要把之前计算出的结果和正在流水线里跑的错误预取的指令和状态冲刷
 掉，而且还要恢复到指令分支时的状态，继续取正取的分支放到流水线里运行。

 可见，如果分支预测的不准就会老是冲刷流水线，后端的执行单元得不到充分利用，用perf
 看就是back-end stall增大。

 分支预测失败的时候要尽快回退到分支点的状态，硬件可以使用checkpoint的方式恢复，
 大概是分支预取的时候把整个状态统一保存，分支预测失败的时候统一一把恢复回来。

指令解码
--------

 解码阶段需要做寄存器的重命名，有时还有把一条执行内部拆分成几条指令。对于超标量
 处理器，可以同时解码多条指令。这个阶段还是顺序进行的，比如4发射的处理器，就同时
 有四条指令送去解码。

 为了使的程序执行对外保持逻辑顺序，处理器实现里一般使用重排序缓冲(ROB reorder buffer)
 在提交之前重排序。ROB的设计逻辑很简单，就是以指令取入的顺序在取入的时候就按顺序
 存在ROB这个队列里，ROB为每个指令都维护了相关的状态，ROB里的指令提交的时候是顺序
 进行的，这样就可以保证先进入的指令先离开处理器。这会导致ROB会被执行慢的指令堵住，
 不过这也没有关系，虽然当前的执行堵住了，但是后面的指令已经在ROB里就绪，一旦这个
 堵住ROB的指令提交，后面的完成的指令可以一次都提交了。当然受ROB深度的限制，一旦
 ROB慢了，就会反压前端的取指单元，这时就会导致front-end stall增大。

 我们可以先跑一个慢的指令比如浮点除法，后面不断的跑NOP指令，这样ROB会被填满，导致
 front-end stall。执行单元以及执行的issue queue满了，都会导致前端反压，构造一个
 这样的场景看看？

 分支预测失败进行回退的时候也要清ROB里的内容。

寄存器重命名
------------

 使用寄存器重命名消除WAW和WAR依赖。具体的实现方式有很多，基本思路就是要识别出代码
 中的依赖，然后重命名消除依赖，指令执行完毕后要把重命名的寄存器重新返回到软件感知
 的构架寄存器上。硬件为了重命名要维护重命名相关的表格。当分支预测失败的时候，也要
 回退寄存器重命名占用的相关资源。

发射
----


执行
----


提交
----


